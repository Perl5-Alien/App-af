#!/usr/bin/perl

use strict;
use warnings;
use 5.014;
use App::af;
use File::chdir;

# PODNAME: af
# ABSTRACT: Command line tool for alienfile
# VERSION

=head1 SYNOPSIS

 af download   --help
 af install    --help
 af test       --help
 af requires   --help
 af missing    --help
 af prop       --help
 af clean      --help

=head1 DESCRIPTION

The C<af> command is a command line interface to L<alienfile> and
L<Alien::Build>.

=head3 options

These options are available for all subcommands.

=head4 --help

Print the help for either C<af> as a whole, or the specific subcommand.

=head4 --version

Print the version of C<af> and exit.

=head1 SUBCOMMANDS

=cut

package App::af::download {
  use Moose;
  use namespace::autoclean;
  use MooseX::Types::Path::Tiny qw( AbsPath );
  use Path::Tiny qw( path );

  with 'App::af';
  with 'App::af::role::alienfile';

=head2 download

=head3 Usage

 af download
   [
     ( -f | --file )  alienfile | 
     ( -c | --class ) class
   ]
   [ ( -l | --local ) directory ]

=head3 description

Download the external resource using the usual L<alienfile> logic.  File
will be deposited in the directory indicated by the C<--local> (or C<-l>)
option, or the current working directory if not specified.

=head3 options

=head4 -f | --file

The L<alienfile>.  If neither this option, nor C<-c> is specified, then 
C<alienfile> in the current directory will be assumed.

=head4 -c | --class

Get the L<alienfile> from the already installed Alien module.

=head4 -l | --local

The location to store the downloaded resource.  The current directory
if not specified.

=cut

  has local => (
    is       => 'ro',
    isa      => AbsPath,
    traits   => ['App::af::opt'],
    short    => 'l',
    coerce   => 1,
    opt_type => 's',
    default  => '.',
  );

  sub main
  {
    my($self) = @_;
    say $self->local;
    
    unless(-d $self->local)
    {
      say STDERR "no such directory: @{[ $self->local ]}";
      return 2;
    }

    local $ENV{ALIEN_INSTALL_TYPE} = 'share';    
    my $build = $self->build;
    $build->load_requires('configure');
    $build->load_requires('share');
    eval { $build->download };
    warn $@ if $@;

    unless(defined $build->install_prop->{download} &&
           length $build->install_prop->{download})
    {
      say STDERR "Recipe did not seem to download a file or directory";
      return 2;
    }
    
    my $download = path($build->install_prop->{download});
    
    if(-f $download)
    {
      my $to = $self->local->child($download->basename);
      $download->copy($to) || die "unable to copy $download => $to $!";
      say "Wrote archive to $to";
    }
    elsif(-d $download)
    {
      require File::Copy::Recursive;
      my $to = $self->local->child($download->basename);
      File::Copy::Recursive::dircopy("$download", "$to") || die "unable to copy $download => $to $!";
      say "Wrote directory to $to";
    }
    else
    {
      say STDERR "Recipe did not seem to download a file or directory";
      return 2;
    }
    
    0;
  }

  __PACKAGE__->meta->make_immutable;
}

# install
#   --prefix
#   --stage
#   -f | --file alienfile
#   -c | --class (Alien::)?foo

## Installs or reinstalls the Alien
## for "-c" mode, --prefix is the distdir
## "--stage" is ~/.alienbuild/af/tmp/XXXXXX by default

package App::af::install {
  use Moose;
  with 'App::af';
  sub main {}
  __PACKAGE__->meta->make_immutable;
}

# test
#   --prefix
#   --stage
#   -f | --file alienfile
#   -c | --class (Alien::)?foo
#   --before
#   --after    # default
#   -p | --phase ( probe | download | extract | patch | build | gather )

## --prefix is ~/.alienbuild/af/tmp/XXXXX by default
## --stage  is ~/.alienbuild/af/tmp/XXXXX by default

package App::af::test {
  use Moose;
  with 'App::af';
  sub main {}
  __PACKAGE__->meta->make_immutable;
}

# requires
#   -f | --file alienfile
#   -c | --class (Alien::)?foo
#   -p | --phase ( configure | any | share | system )

## prints in YAML format either all requirements, or the reqs
## for the particular phase

package App::af::requires {
  use Moose;
  with 'App::af';
  sub main {}
  __PACKAGE__->meta->make_immutable;
}

# missing
#   -f | --file alienfile
#   -c | --class (Alien::)?foo
#   -p | --phase ( configure | any | share | system )

## prints list of modules not apparently already installed.
## Without phase, will execute probe to determine which phase
## to do.

package App::af::missing {
  use Moose;
  with 'App::af';
  sub main {}
  __PACKAGE__->meta->make_immutable;
}

# prop
#   -c | --class (Alien::)?foo
#   --static
#   --cflags
#   --libs
#   --modversion
#   --bin-dir

## prints the runtime properties of the already installed Alien

package App::af::prop {
  use Moose;
  use namespace::autoclean;
  use Module::Load qw( load );
  
  with 'App::af';

  has class => (
    is       => 'ro',
    isa      => 'Str',
    traits   => ['App::af::opt'],
    short    => 'c',
    opt_type => 's',
  );
  
  has $_ => (
    is       => 'ro',
    isa      => 'Int',
    traits   => ['App::af::opt'],
  ) for qw( static cflags libs modversion bin_dir );

  sub main {
    my($self) = @_;
    
    unless($self->class)
    {
      say STDERR "You must specify a class.\n";
      return 2;
    }
    
    my $class = $self->class =~ /::/ ? $self->class : 'Alien::' . $self->class;

    load $class;    
    unless($class->can('runtime_prop'))
    {
      say STDERR "$class was not installed with Alien::Build";
      return 2;
    }
    
    my $prop = $class->runtime_prop;
    
    unless($prop)
    {
      say STDERR "$class was not installed with Alien::Build";
      return 2;
    }
    
    my $found = 0;
    
    if($self->cflags)
    {
      if($self->static)
      {
        say $class->cflags_static;
      }
      else
      {
        say $class->cflags;
      }
      $found = 1;
    }
    
    if($self->libs)
    {
      if($self->static)
      {
        say $class->libs_static;
      }
      else
      {
        say $class->libs;
      }
      $found = 1;
    }
    
    if($self->bin_dir)
    {
      say $_ for $class->bin_dir;
      $found = 1;
    }
    
    if($self->modversion)
    {
      say $class->version // 'undef';
      $found = 1;
    }
    
    unless($found)
    {
      require YAML;
      print YAML::Dump($prop);
    }
    
    0;
  }
  __PACKAGE__->meta->make_immutable;
}

# for testing, allow us to do this file
# without running.
unless(caller)
{
  my $app = App::af->compute_class->new(@ARGV);
  exit($app->main // 0);
}
